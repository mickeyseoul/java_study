▶상속
extends 부모클래스

부모클래스
자식클래스
  부모클래스의 멤버변수, 메서드를 상속받음  //X생성자
    super. : 부모의 변수,메서드에 접근할 때 사용
    부모클래스의 private변수는 직접 사용하지 못함 -> 부모클래스의 메서드를 통해서만 불러올 수 있음***
  자식클래스의 생성자의 super();
    자식 클래스 생성자에만 첫줄에 필수적 생성됨
    부모 생성자를 호출하는 코드
    안써도 기본으로 들어간다
    어떤 매개변수가 들어있건 오직 1개의 super();만 가능***
    특히 super()가 매개변수가 없는 경우 매개변수없는 기본 부모 생성자 존재해야 함
    부모생성자는 자식 생성자의 super()로만 접근 가능
  

▶오버라이딩
부모/자식 클래스의 상속관계에서 똑같은 이름 메서드(매개변수의 데이터 타입/갯수 완벽 일치)라면 -> 자식 메서드 사용***
cf)오버로딩: 하나의 클래스 안에 똑같은 이름 메서드(매개변수의 데이터 타입/갯수 다름)가 여러개


▶다형성 Polymorphism
업캐스팅    :부모클래스 참조변수 = new 자식클래스();
다운캐스팅  :자식클래스 참조변수 = (자식클래스)부모클래스 참조변수;  //업캐스팅이 있어야 다운캐스팅을 할 수 있다.
    *
    if(c instanceof FireEngine) { //부모타입 c변수를 자식타입 FireEngine으로 다운캐스팅할수 있나? //연산자 instanceof***
			System.out.println("다운캐스팅 가능");
    }
    
▷업캐스팅시 출력되는 것:
공통 멤버변수 -> 부모꺼
공통 메서드 -> 자식꺼

모만 갖고있는 멤버변수/메서드 -> 부모꺼 사용   cf)생성자는 객체 생성될때 호출되는 것. 출력안됨
자식만 갖고있는 멤버변수/메서드 -> 출력 안됨

▷다형성의 목적***
Empno[] arr = new Empno[3];
arr[0] = FullTime("우기",30,서울);
arr[1] = Contract("설리",28);
arr[2] = PartTime("유아",33);
부모참조타입 '객체배열'을 만들어, 각각의 객체에 생성자를 통해 정보를 각각 넣은 다음,
부모참조타입으로 생성된 각각의 객체의 공통된 분야의 정보를 
for문을 사용해 '한번에' 뽑아낼 수 있음 print()!


▶추상클래스
추상클래스, 인터페이스 스스로의 객체 못만든다.
미완성(abstract) 메서드가 하나라도 있으면(abstract클래스) 스스로의 객체는 못만듬
오직 상속/구현시키며 미완성메서드를 통해 반드시 실현해야할 메서드를 상기시켜주는 역할을 함.
+다형성을 통해 공통된 분야의 데이터를 한번에 뽑아낼 수 있는 역할도 함(추상클래스만)


▶인터페이스 interface: 접속하다

▶추상클래스/인터페이스

하나의 클래스가 상속/인터페이스 둘 다 받을 수 있음
상속 - extends
인터페이스 - implements

▷추상클래스상속와 인터페이스 비교
추상클래스상속: 
오직 하나의 부모만 상속받음
abstract/일반 메서드 둘다 존재 가능

인터페이스: 
다중 부모 상속받음 가능
abstract 메서드만(abstract 생략되어있음)
public abstract 미완성메서드에 생략되어있음 -> 구현하는 클래스에서 메서드 앞에 public 붙여줘야함
초기화 된 변수 절대 못바꿈(final 생략되어있음)


